###############################################################
# File allowing the dialog between testing module and the API #
###############################################################

# --- Adaptive function between the testing tool and the API ---
# From a number between 0 and 1, convert it to a specific call (endpoint) for the API
# Need to know how many different endpoint are available
# Need to know how many args are necessary for the call (GET will only need and ID but a PUT will need an ID and all the required arguments)

import math
import random
import requests

Endpoints = ["GET", "PUT", "PATCH", "DELETE"]
APIContent = ["Client"] #, "Manufacturer", "Something"]  # If dict: "manufacturer": ManufacturerEndpoints ...

BASE = "http://127.0.0.1:5000/"

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class Adapter():

    # First idea of function:
    # Inputs:
    #   - self: Inside a class
    #   - inputs: A tuple containing numbers (in [0; 1]) from the testing tool
    # Some needed variables:
    #   - N: Number of callable endpoints (parsing the 0 to 1 segment to N smaller segments)
    #   - id: Necessary? The id of the client
    #   - dict: Python dictionnary with the necessary arguments to call the endpoint
    # Return:
    #   - Do I need to process here the information about the performances? And therfore return a summarized information like a reward for instance
    #   - If no I can return the console string output (that's the simplest) and parse it later (Hard for nothing?)
    def inputToEndpoint(self, inputs, debug):
        # --- DEBUG mode check ---
        if debug: print(f"{bcolors.OKBLUE}DEBUG MODE ACTIVATED{bcolors.ENDC}")

        # --- Inputs check ---
        nb_inputs = len(inputs)
        for i in inputs:
            if i in range(0, 1):
                print(f"{bcolors.FAIL}Error, in {inputs} one probability is not between 0 and 1: {i}{bcolors.ENDC}")
                return
        if nb_inputs == 1:
            input  = inputs[0]
            input2 = inputs[0]
        else:
            input  = inputs[0]
            input2 = inputs[1]
            if nb_inputs >= 3:
                print(f"{bcolors.WARNING}Third input and more will not be used.{bcolors.ENDC}")
        if debug: print(f"Inputs: {inputs}, nb_inputs = {nb_inputs}, input1 = {input} and input2 = {input2}.")

        # --- Get API information ---
        nb_resources = len(APIContent)
        nb_endpoints = len(Endpoints)

        # --- Security Check ---
        resource_lenght = 1/nb_resources
        double_precision_check = resource_lenght*nb_resources
        if debug: print(f"Length of the segment: {resource_lenght}, resource_lenght * nb_resources = {double_precision_check}")

        # --- Get resource name ---
        resource_index = math.ceil(nb_resources * input) - 1
        resource_name = APIContent[resource_index].lower()
        if debug: print(f"Resource index: \"{resource_index}\", Resource Name: \"{resource_name}\".")

        # --- Get endpoint Name ---
        endpoint_lenght = resource_lenght/nb_endpoints
        # The endpoint_prob variable is just the input variable rescaled in [0; resource_lenght]
        endpoint_prob = input - (resource_lenght * resource_index)
        if debug: print(f"Endpoint lenght: \"{endpoint_lenght}\", Endpoint probability: \"{endpoint_prob}\".")

        endpoint_index = math.ceil(nb_endpoints * endpoint_prob * nb_resources) - 1
        endpoint_name = Endpoints[endpoint_index].lower()
        if debug: print(f"Endpoint index: \"{endpoint_index}\", Endpoint Name: \"{endpoint_name}\".")

        # --- Get endpoint call function ---
        #response = requests.models.Response()
        adress = BASE + "client/0"

        # --- Make the call ---
        switch_endpoints_dict = {"get": Adapter.callGet, "put": Adapter.callPut, "patch": Adapter.callPatch, "delete": Adapter.callDelete}
        response = switch_endpoints_dict[endpoint_name](self, BASE, resource_name, input2, debug)

        # --- Get the information generated by the call (printed in console?) ---
        print(response)
        if endpoint_name != "delete": # "Delete" request doesn't return json
            print(response.json())

        # --- Analyze it ---
        # ... later
        # --- For Performance testing ---
        # Could measure the time execution, can make it fake for the moment, return a fake number: The higher the better
        # Use a second input to generate the id, but a third value is not necessary to modify other arguments (i.e. PUT)

        # --- Deduce reward ---
        # For the moment deducing a fake reward (depending on the endpoint)
        fake_execution_time = self.getFakeRewardFromEndpoint(endpoint_index)

        return fake_execution_time

    def callGet(self, BASE, resource_name, input2, debug):
        # --- Generate id from input2 ---
        id = math.ceil(input2 * 100) - 1
        adress = BASE + resource_name + "/" + str(id)
        if debug: print(f"From {input2}, {adress} has been generated.")

        # --- Call ---
        print(f"{bcolors.OKCYAN}Calling: \"response = requests.get(\"{adress}\")\"{bcolors.ENDC}")
        exec(f"global response; response = requests.get(\"{adress}\")")
        # May need to use global and local parameters with exec()
        # Check "https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile"
        return response

    def callPut(self, BASE, resource_name, input2, debug):
        # --- Generate id from input2 ---
        id = math.ceil(input2 * 100) - 1
        adress = BASE + resource_name + "/" + str(id)
        if debug: print(f"From {input2}, {adress} has been generated.")

        # --- Generate request body ---
        #curly1 = "{"; curly2 = "}"   # Didn't find way to "backslash" curlys in f-string
        body = "{\"name\": \"name" + str(id) + "\", \"gender\": \"female\", \"age\": " + str(id) + "}"

        # --- Call ---
        print(f"{bcolors.OKCYAN}Calling: \"response = requests.put(\"{adress}\", {body})\"{bcolors.ENDC}")
        exec(f"global response; response = requests.put(\"{adress}\", {body})")
        return response

    def callPatch(self, BASE, resource_name, input2, debug):
        # --- Generate id from input2 ---
        id = math.ceil(input2 * 100) - 1
        adress = BASE + resource_name + "/" + str(id)
        if debug: print(f"From {input2}, {adress} has been generated.")

        # --- Generate request body ---
        # Use the random module to generate new args (only name and age, gender stays the same)
        random.seed(id)
        # Use input2 to choose how many args will be "patched"
        # cases: nb_patch ==
        # 1: change only name
        # 2: change name and gender
        # 3: change name and age
        # 4; change everything
        nb_patch = (id % 4) + 1 # Get a nb of args to patch between 1 to 3 (complete change)
        new_body = "{\"name\": \"newName" + str(random.randint(1,100)) + "\""
        if nb_patch == 2:
            new_body += ", \"gender\": \"male\""
        if nb_patch == 3:
            new_body += ", \"age\": " + str(random.randint(1,100))
        if nb_patch == 4:
            new_body += ", \"gender\": \"male\", \"age\": " + str(random.randint(1,100))
        new_body += "}"
        if debug:
            print(f"From {input2}, {nb_patch} will be patched. The new body is: {new_body}")

        # --- Call ---
        print(f"{bcolors.OKCYAN}Calling: \"response = requests.patch(\"{adress}\", {new_body})\"{bcolors.ENDC}")
        exec(f"global response; response = requests.patch(\"{adress}\", {new_body})")
        return response

    def callDelete(self, BASE, resource_name, input2, debug):
        # --- Generate id from input2 ---
        id = math.ceil(input2 * 100) - 1
        adress = BASE + resource_name + "/" + str(id)
        if debug:
            print(f"From {input2}, {adress} has been generated.")

        # --- Call ---
        print(f"{bcolors.OKCYAN}Calling: \"response = requests.delete(\"{adress}\")\"{bcolors.ENDC}")
        exec(f"global response; response = requests.delete(\"{adress}\")")
        return response

    #
    def getFakeRewardFromEndpoint(self, index):
        if index == 0:
            print(f"Fake Reward Computation: Index = {index}, Endpoint = GET, Return 10.")
            return 10
        elif index == 1:
            print(f"Fake Reward Computation: Index = {index}, Endpoint = PUT, Return 40.")
            return 40
        elif index == 2:
            print(f"Fake Reward Computation: Index = {index}, Endpoint = PATCH, Return 20.")
            return 20
        elif index == 3:
            print(f"Fake Reward Computation: Index = {index}, Endpoint = DELETE, Return 1000.")
            return 1000
        else:
            print(f"{bcolors.WARNING}Fake Reward Computation: Unknown Index = {index}, Return 100.{bcolors.ENDC}")
            return 100
